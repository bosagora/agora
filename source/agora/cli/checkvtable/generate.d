/*******************************************************************************

    The agora-checkvtable-gen for generating C++ source code

    Copyright:
        Copyright (c) 2020 BOS Platform Foundation Korea
        All rights reserved.

    License:
        MIT License. See LICENSE for details.

*******************************************************************************/

module agora.cli.checkvtable.generate;

import agora.cli.checkvtable.types;

import std.file;
import std.format;
import std.stdio;

version (Windows) { pragma(msg, "This does not support Windows."); } else:

version (unittest) { } else

/// This is agora-checkvtable-gen for generating C++ source code
private int main (string[] args)
{
    if (args.length < 2)
    {
        writeln("usage: agora-checkvtable-gen output-file-name");
        return 1;
    }
    string[] outputs;
    auto filename = args[1];
    writecode(outputs);
    File file = File(filename, "w");

    foreach (ref line; outputs)
        file.writeln(line);

    file.close();

    writefln("Source code was generated with the file name %s.", filename);
    return 0;
}

/// Writes C++ source code to outputs
private void writecode (ref string[] outputs)
{
    writeHeader(outputs);

    static foreach (name; VTableCheckClasses)
    {
        outputs ~= writeMethod_getVMOffset_each!(name)(name);
        outputs ~= writeMethod_checkVMOffset_each!(name)(name);
    }

    outputs ~= writeMethod_checkVMOffset!(VTableCheckClasses)(VTableCheckClasses);
}

/// Writes a method getVMOffset******** of a class
private string[] writeMethod_getVMOffset_each (string CTName)(string RTName)
{
    string[] outputs;
    mixin(
    q{
        writeMethodHeader(outputs, `%1$s`, `getVMOffset%1$s`);
        static foreach (idx, member; __traits(allMembers, %1$s))
        {
            mixin(
            q{
                static if (__traits(isVirtualMethod, %1$s.%2$s) && (`%2$s` != `__dtor`) && (`%2$s` != `__xdtor`))
                {
                    writeMethodContents(outputs, `%1$s`, `%2$s`);
                }
            }.format(`%1$s`, member));
        }
        writeMethodFooter(outputs);
    }.format(CTName, `%2$s`));

    return outputs;
}

version (unittest)
extern (C++) public class TestA
{
public:
    ~this()
    {
    }
    abstract void vfunc1();
    abstract void vfunc2();
}

/// Writes a method checkVMOffset******** of a class
private string[] writeMethod_checkVMOffset_each (string CTName)(string RTName)
{
    string[] outputs;
    outputs ~= format(
`///  Checks the offset of virtual methods inside the class %s.
int checkVMOffset%s (const char* offsets)
{
    istringstream lines(offsets);
    string line, field;
    int line_idx, field_idx;

    line_idx = 0;
    while (getline(lines, line, ':'))
    {
        istringstream fields(line);
        string method;
        int offset;
        field_idx = 0;
        while (getline(fields, field, '='))
        {
            if (field_idx == 0)
                method = field;
            else if (field_idx == 1)
                offset = stoi(field);
            else break;
            field_idx++;
        }

        if (field_idx >= 1)
        {
            if (getVMOffset%s(method.c_str()) != offset)
                return line_idx+1;
        }
        line_idx++;
    }

    return 0;
}
`, CTName, CTName, CTName);

    return outputs;
}

/// Writes a method checkVMOffset
private string[] writeMethod_checkVMOffset (immutable(string[]) CTName)(immutable(string[]) RTName)
{
    string[] outputs;

    outputs ~= `int checkVMOffset (const char* classname, const char* offsets)`;
    outputs ~= `{`;

    static foreach (name; CTName)
    {
        mixin(
        q{
            outputs ~= `    if (strcmp(classname, "%1$s") == 0)`;
            outputs ~= `        return checkVMOffset%1$s(offsets);`;
            outputs ~= ``;
        }.format(name));
    }

    outputs ~= `    return -1;`;
    outputs ~= `}`;

    return outputs;
}

/// Writes the header of the source file
private void writeHeader (ref string[] outputs)
{
    outputs ~= format(
`/*******************************************************************************

    Contains checking the offset of virtual methods.

    Note:
        This was automatically generated by agora-checkvtable.
        Do not modify this file.
        If you want to modify it, please use agora-checkvtable.
        agora-checkvtable-gen source/scpp/extra/DVMChecks.cpp
        or
        dub -c checkvtable-gen -- source/scpp/extra/DVMChecks.cpp

    Copyright:
        Copyright (c) 2020 BOS Platform Foundation Korea
        All rights reserved.

    License:
        MIT License. See LICENSE for details.

*******************************************************************************/

#include "scp/SCPDriver.h";

#include <iostream>
#include <string>
#include <sstream>

using namespace std;
using namespace stellar;
`
    );
}

/// Writes the name of the method
private void writeMethodHeader (ref string[] outputs, string class_name, string method_name)
{
    outputs ~= "///  Returns the offset of virtual methods inside the class " ~ class_name ~ ".";
    outputs ~= "long " ~ method_name ~ " (const char* name)";
    outputs ~= "{";
}

/// Writes the end of the method
private void writeMethodFooter (ref string[] outputs)
{
    outputs ~= "    return -1;";
    outputs ~= "}";
    outputs ~= "";
}

/// Writes the contents of the method
private void writeMethodContents (ref string[] outputs, string entry, string method)
{
    outputs ~= "    if (strcmp(name, \"" ~ method ~ "\") == 0)";
    outputs ~= "    {";
    outputs ~= "        auto pf = &"~ entry ~ "::" ~ method ~ ";";
    outputs ~= "        return ((long)reinterpret_cast<void *&>(pf)) / sizeof(long);";
    outputs ~= "    }";
}

// Test whether the output of `writeMethod_getVMOffset_each` is equal to the expected value.
static unittest
{
    import std.array;
    immutable expected =
`///  Returns the offset of virtual methods inside the class TestA.
long getVMOffsetTestA (const char* name)
{
    if (strcmp(name, "vfunc1") == 0)
    {
        auto pf = &TestA::vfunc1;
        return ((long)reinterpret_cast<void *&>(pf)) / sizeof(long);
    }
    if (strcmp(name, "vfunc2") == 0)
    {
        auto pf = &TestA::vfunc2;
        return ((long)reinterpret_cast<void *&>(pf)) / sizeof(long);
    }
    return -1;
}
`;
    static assert (expected == join(writeMethod_getVMOffset_each!("TestA")("TestA"), "\n"));
}

// Test whether the output of `writeMethod_checkVMOffset_each` is equal to the expected value.
static unittest
{
    import std.array;
    immutable expected =
`///  Checks the offset of virtual methods inside the class TestA.
int checkVMOffsetTestA (const char* offsets)
{
    istringstream lines(offsets);
    string line, field;
    int line_idx, field_idx;

    line_idx = 0;
    while (getline(lines, line, ':'))
    {
        istringstream fields(line);
        string method;
        int offset;
        field_idx = 0;
        while (getline(fields, field, '='))
        {
            if (field_idx == 0)
                method = field;
            else if (field_idx == 1)
                offset = stoi(field);
            else break;
            field_idx++;
        }

        if (field_idx >= 1)
        {
            if (getVMOffsetTestA(method.c_str()) != offset)
                return line_idx+1;
        }
        line_idx++;
    }

    return 0;
}
`;
    static assert (expected == join(writeMethod_checkVMOffset_each!("TestA")("TestA"), "\n"));
}

// Test whether the output of `writeMethod_checkVMOffset` is equal to the expected value.
static unittest
{
    immutable CheckClasses =
    [
        "TestA",
        "TestB"
    ];

    import std.array;
    immutable expected =
`int checkVMOffset (const char* classname, const char* offsets)
{
    if (strcmp(classname, "TestA") == 0)
        return checkVMOffsetTestA(offsets);

    if (strcmp(classname, "TestB") == 0)
        return checkVMOffsetTestB(offsets);

    return -1;
}`;
    static assert (expected == join(writeMethod_checkVMOffset!(CheckClasses)(CheckClasses), "\n"));
}
